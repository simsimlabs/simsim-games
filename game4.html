<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë¸”ë™í™€ í‚¤ìš°ê¸° - ì‹¬ì‹¬í’€ì´ ê²Œì„ ì—°êµ¬ì†Œ</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2261846676525942" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap');

        body { 
            margin: 0; padding: 0; overflow: hidden; background-color: #34495e; 
            font-family: 'Noto Sans KR', sans-serif; user-select: none; touch-action: none;
        }

        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        .game-overlay { pointer-events: none; position: fixed; z-index: 100; }

        #game-ui { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 9999; background: rgba(255, 255, 255, 0.98);
            padding: 40px; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            text-align: center; width: 90%; max-width: 420px; border: 5px solid #6c5ce7;
            pointer-events: auto;
        }

        #game-ui h1 { font-family: 'Jua', sans-serif; font-size: 3rem; color: #1a1a1a; margin: 0 0 10px 0; text-shadow: 2px 2px 0px #bdc3c7; }
        #game-ui p { color: #636e72; font-size: 1.1rem; margin-bottom: 20px; }

        #start-btn {
            background: #2c3e50; color: white; border: none; padding: 15px 0;
            font-size: 1.8rem; font-family: 'Jua', sans-serif; border-radius: 50px;
            cursor: pointer; box-shadow: 0 6px 0 #1a252f; width: 100%; margin-bottom: 15px; transition: transform 0.1s; display: block;
        }
        #start-btn:active { transform: translateY(4px); box-shadow: none; }

        .back-link { display: inline-block; margin-top: 10px; color: #7f8c8d; text-decoration: none; cursor: pointer; }
        .back-link:hover { color: #2c3e50; text-decoration: underline; }

        #leaderboard { top: 15px; right: 15px; background: rgba(0,0,0,0.6); color: white; padding: 15px; border-radius: 10px; font-family: 'Jua', sans-serif; min-width: 160px; }
        #rank-list { list-style: none; padding: 0; margin: 0; font-size: 0.95rem; }
        #rank-list li { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }

        #kill-log { bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(44, 62, 80, 0.9); color: white; padding: 10px 25px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s; }

        #ingame-ad { position: fixed; bottom: 10px; right: 10px; z-index: 50; background: white; padding: 5px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2); pointer-events: auto; display: none; }
        .ad-label { font-size: 10px; color: #ccc; text-align: right; display: block; }

        #joystick-zone { position: fixed; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 200; display: none; pointer-events: auto; }
        #joystick-bg { width: 100%; height: 100%; background: rgba(0, 0, 0, 0.2); border-radius: 50%; position: relative; border: 2px solid rgba(255,255,255,0.5); }
        #joystick-stick { width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(0,0,0,0.2); }

        @media (max-width: 600px) {
            #game-ui { width: 85%; }
            #ingame-ad { transform: scale(0.8); transform-origin: bottom right; bottom: 5px; right: 5px; }
            #joystick-zone { display: block; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="leaderboard" class="game-overlay">
        <h3>ğŸ† ì‹¤ì‹œê°„ ë­í‚¹</h3>
        <ul id="rank-list"><li>ë¡œë”© ì¤‘...</li></ul>
    </div>

    <div id="kill-log" class="game-overlay"></div>

    <div id="joystick-zone">
        <div id="joystick-bg"><div id="joystick-stick"></div></div>
    </div>

    <div id="ingame-ad">
        <span class="ad-label">Sponsored</span>
        <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-2261846676525942" data-ad-slot="4380369066"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <div id="game-ui">
        <h1>ğŸ•³ï¸ ë¸”ë™í™€ í‚¤ìš°ê¸°</h1>
        <p>ë„ì‹œì˜ ëª¨ë“  ê²ƒì„ ì‚¼í‚¤ì„¸ìš”!<br>ì‚¬ëŒ â†’ ìë™ì°¨ â†’ ê±´ë¬¼ ìˆœìœ¼ë¡œ ë¨¹ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        <div style="margin: 15px 0; min-height: 100px; overflow:hidden;">
             <ins class="adsbygoogle" style="display:block; height: 100px;" data-ad-client="ca-pub-2261846676525942" data-ad-slot="4380369066" data-ad-format="horizontal" data-full-width-responsive="true"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        <button id="start-btn">ê²Œì„ ì‹œì‘ â–¶</button>
        <br>
        <a href="index.html" class="back-link">ğŸ  ë©”ì¸ìœ¼ë¡œ ë‚˜ê°€ê¸°</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('game-ui');
        const rankList = document.getElementById('rank-list');
        const killLog = document.getElementById('kill-log');
        const ingameAd = document.getElementById('ingame-ad');
        const startBtn = document.getElementById('start-btn');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickStick = document.getElementById('joystick-stick');

        const MAP_SIZE = 3000;
        const MAP_BG_COLOR = '#ecf0f1';
        
        let holes = [];
        let props = []; // ë¨¹ì´(ì‚¬ë¬¼)ë“¤
        let gameRunning = false;
        let animationFrameId;
        
        let playerIndex = -1;
        let inputType = 'mouse';
        let mouseX = 0, mouseY = 0;
        let joystickVector = { x: 0, y: 0 };

        const adjectives = ["ë°°ê³ í”ˆ", "ê²€ì€", "ë¬´ì„œìš´", "ê±°ëŒ€í•œ", "ìˆ˜ìƒí•œ", "ê°•ë ¥í•œ", "ì‹¬ì—°ì˜", "ìš°ì£¼", "ì°¨ì›ì˜"];
        const nouns = ["ë¸”ë™í™€", "êµ¬ë©", "ì‹±í¬í™€", "í¬ì‹ì", "ì²­ì†Œê¸°", "ê´´ë¬¼", "ê³µí—ˆ", "ìœ ë ¹"];
        function getName() { return adjectives[Math.floor(Math.random()*adjectives.length)] + " " + nouns[Math.floor(Math.random()*nouns.length)]; }

        // ì‚¬ë¬¼ ìœ í˜• ì •ì˜
        const PROP_TYPES = [
            { type: 0, color: '#27ae60', r: 4, score: 1 },   // ì‚¬ëŒ/í’€ (ê°€ì¥ ì‘ìŒ)
            { type: 1, color: '#e67e22', r: 8, score: 3 },   // ë²¤ì¹˜/ë°•ìŠ¤
            { type: 2, color: '#e74c3c', r: 12, score: 5 },  // ìë™ì°¨
            { type: 3, color: '#95a5a6', r: 20, score: 15 }, // ì‘ì€ ê±´ë¬¼
            { type: 4, color: '#34495e', r: 35, score: 30 }  // í° ê±´ë¬¼
        ];

        document.addEventListener('DOMContentLoaded', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(startBtn) startBtn.addEventListener('click', startGame);
            mouseX = window.innerWidth/2; mouseY = window.innerHeight/2;
            initJoystick();
            window.addEventListener('mousemove', e => { if(inputType!=='joystick') { mouseX=e.clientX; mouseY=e.clientY; } });
            window.addEventListener('mousedown', () => inputType='mouse');
            window.addEventListener('resize', () => { canvas.width=window.innerWidth; canvas.height=window.innerHeight; });
        });

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            gameRunning = true;
            holes = [];
            props = [];

            // ì‚¬ë¬¼ ìƒì„± (ëŒ€ëŸ‰)
            for(let i=0; i<1500; i++) addProp();

            // í”Œë ˆì´ì–´ ìƒì„±
            playerIndex = addHole(true);
            
            // ë´‡ ìƒì„±
            for(let i=0; i<15; i++) addHole(false);

            ui.style.display = 'none';
            ingameAd.style.display = 'block';
            loop();
        }

        function addHole(isHuman) {
            let r = 20; // ì´ˆê¸° í¬ê¸°
            // ë´‡ì€ ë‹¤ì–‘í•œ í¬ê¸°ë¡œ ì‹œì‘
            if(!isHuman) r = 20 + Math.random() * 20;

            let hole = {
                isHuman: isHuman,
                x: Math.random() * (MAP_SIZE - 200) + 100,
                y: Math.random() * (MAP_SIZE - 200) + 100,
                r: r,
                color: isHuman ? '#000000' : '#1a1a1a',
                rimColor: isHuman ? '#6c5ce7' : `hsl(${Math.random()*360}, 70%, 50%)`,
                name: isHuman ? 'ë‚˜ (Player)' : getName(),
                score: 0,
                dead: false,
                aiTargetX: 0, aiTargetY: 0, aiTimer: 0
            };
            holes.push(hole);
            return holes.length - 1;
        }

        function addProp() {
            // í™•ë¥ ì ìœ¼ë¡œ í° ì‚¬ë¬¼ ìƒì„± (ì‘ì€ê²Œ ë” ë§ê²Œ)
            let rand = Math.random();
            let typeIdx = 0;
            if (rand < 0.6) typeIdx = 0;      // 60%
            else if (rand < 0.85) typeIdx = 1; // 25%
            else if (rand < 0.95) typeIdx = 2; // 10%
            else if (rand < 0.98) typeIdx = 3; // 3%
            else typeIdx = 4;                  // 2%

            let type = PROP_TYPES[typeIdx];
            
            props.push({
                x: Math.random() * MAP_SIZE,
                y: Math.random() * MAP_SIZE,
                ...type,
                alive: true,
                suckTarget: null // ë¹¨ë ¤ë“¤ì–´ê°ˆ ëŒ€ìƒ
            });
        }

        function initJoystick() {
            let stick = joystickStick;
            let zone = joystickZone;
            let maxDist = 35; let active = false;
            
            zone.addEventListener('touchstart', e => {
                e.preventDefault(); active=true; inputType='joystick';
                let t = e.touches[0];
                let rect = zone.getBoundingClientRect();
                updateStick(t.clientX, t.clientY, rect.left+rect.width/2, rect.top+rect.height/2);
            }, {passive:false});

            zone.addEventListener('touchmove', e => {
                if(!active) return;
                e.preventDefault();
                let t = e.touches[0];
                let rect = zone.getBoundingClientRect();
                updateStick(t.clientX, t.clientY, rect.left+rect.width/2, rect.top+rect.height/2);
            }, {passive:false});

            zone.addEventListener('touchend', e => {
                e.preventDefault(); active=false;
                stick.style.transform = `translate(-50%, -50%)`;
                joystickVector = {x:0, y:0};
            });

            function updateStick(clientX, clientY, centerX, centerY) {
                let dx = clientX - centerX;
                let dy = clientY - centerY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                joystickVector = {x: dx, y: dy};
            }
        }

        function loop() {
            if(!gameRunning) return;

            // ë°°ê²½
            ctx.fillStyle = MAP_BG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let player = holes[playerIndex];
            let zoom = 1;
            if(player && !player.dead) zoom = Math.max(0.3, 30 / (player.r + 20));

            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(zoom, zoom);
            if(player && !player.dead) ctx.translate(-player.x, -player.y);
            else ctx.translate(-MAP_SIZE/2, -MAP_SIZE/2);

            // ë§µ ê·¸ë¦¬ë“œ (ë„ë¡œ ëŠë‚Œ)
            ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.beginPath();
            for(let x=0; x<=MAP_SIZE; x+=150) { ctx.moveTo(x,0); ctx.lineTo(x,MAP_SIZE); }
            for(let y=0; y<=MAP_SIZE; y+=150) { ctx.moveTo(0,y); ctx.lineTo(MAP_SIZE,y); }
            ctx.stroke();
            ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 10; ctx.strokeRect(0,0,MAP_SIZE,MAP_SIZE);

            // ì‚¬ë¬¼ ì²˜ë¦¬ ë° ê·¸ë¦¬ê¸°
            for(let i=props.length-1; i>=0; i--) {
                let p = props[i];
                if(!p.alive) continue;

                // í™”ë©´ ë°– ìµœì í™”
                if(player && !player.dead && Math.abs(p.x - player.x) > (canvas.width/zoom + 50)) continue;

                // ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” íš¨ê³¼
                let drawX = p.x;
                let drawY = p.y;
                let drawR = p.r;

                if(p.suckTarget && !p.suckTarget.dead) {
                    // ë¹¨ë ¤ë“¤ì–´ê°
                    let dx = p.suckTarget.x - p.x;
                    let dy = p.suckTarget.y - p.y;
                    p.x += dx * 0.15;
                    p.y += dy * 0.15;
                    drawR = p.r * (1 - 0.15); // ì ì  ì‘ì•„ì§
                    
                    if(Math.hypot(dx, dy) < 5) {
                        // ì™„ì „íˆ ë¨¹í˜
                        p.suckTarget.score += p.score;
                        p.suckTarget.r += p.score * 0.05; // ì„±ì¥
                        props.splice(i, 1);
                        if(Math.random() < 0.2) addProp(); // ë¦¬í•„
                        continue;
                    }
                }

                // ê·¸ë¦¬ê¸° (ë„¤ëª¨ or ì›)
                ctx.fillStyle = p.color;
                ctx.beginPath();
                if(p.type >= 1) ctx.fillRect(drawX - drawR, drawY - drawR, drawR*2, drawR*2); // ë„¤ëª¨
                else ctx.arc(drawX, drawY, drawR, 0, Math.PI*2); // ì›
                ctx.fill();
            }

            // ë¸”ë™í™€ ì²˜ë¦¬
            holes.forEach((h, index) => {
                if(h.dead) return;

                // ì´ë™ ë¡œì§
                let dx = 0, dy = 0;
                let speed = 3 + (50 / h.r); // í¬ë©´ ëŠë ¤ì§

                if(h.isHuman) {
                    if(inputType === 'joystick') { dx = joystickVector.x; dy = joystickVector.y; }
                    else {
                        let angle = Math.atan2(mouseY - canvas.height/2, mouseX - canvas.width/2);
                        let dist = Math.hypot(mouseX - canvas.width/2, mouseY - canvas.height/2);
                        if(dist > 10) { dx = Math.cos(angle); dy = Math.sin(angle); }
                    }
                    // ì •ê·œí™”
                    let len = Math.hypot(dx, dy);
                    if(len > 1) { dx/=len; dy/=len; }
                } else {
                    // AI
                    h.aiTimer--;
                    if(h.aiTimer <= 0) {
                        h.aiTimer = Math.random() * 20 + 10;
                        
                        // 1. í°ë†ˆ í”¼í•˜ê¸°
                        let danger = false;
                        for(let other of holes) {
                            if(h !== other && !other.dead && other.r > h.r * 1.1) {
                                let d = Math.hypot(h.x - other.x, h.y - other.y);
                                if(d < 300) {
                                    h.aiTargetX = h.x - (other.x - h.x); // ë°˜ëŒ€ ë°©í–¥
                                    h.aiTargetY = h.y - (other.y - h.y);
                                    danger = true;
                                    break;
                                }
                            }
                        }

                        // 2. ë¨¹ì´/ì‘ì€ë†ˆ ì°¾ê¸°
                        if(!danger) {
                            let closest = null;
                            let minDist = 400;
                            
                            // ì‘ì€ ë¸”ë™í™€ ìš°ì„ 
                            for(let other of holes) {
                                if(h !== other && !other.dead && h.r > other.r * 1.1) {
                                    let d = Math.hypot(h.x - other.x, h.y - other.y);
                                    if(d < minDist) { minDist = d; closest = {x:other.x, y:other.y}; }
                                }
                            }

                            // ì—†ìœ¼ë©´ ì‚¬ë¬¼
                            if(!closest) {
                                for(let p of props) {
                                    if(!p.alive || p.suckTarget) continue;
                                    if(h.r > p.r) { // ë¨¹ì„ ìˆ˜ ìˆëŠ” ê²ƒë§Œ
                                        let d = Math.hypot(h.x - p.x, h.y - p.y);
                                        if(d < minDist) { minDist = d; closest = p; }
                                    }
                                }
                            }

                            if(closest) {
                                h.aiTargetX = closest.x;
                                h.aiTargetY = closest.y;
                            } else {
                                // ëœë¤
                                h.aiTargetX = Math.random() * MAP_SIZE;
                                h.aiTargetY = Math.random() * MAP_SIZE;
                            }
                        }
                    }
                    let angle = Math.atan2(h.aiTargetY - h.y, h.aiTargetX - h.x);
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                }

                h.x += dx * speed;
                h.y += dy * speed;
                h.x = Math.max(0, Math.min(MAP_SIZE, h.x));
                h.y = Math.max(0, Math.min(MAP_SIZE, h.y));

                // ê·¸ë¦¬ê¸° (ë¸”ë™í™€)
                ctx.beginPath();
                ctx.arc(h.x, h.y, h.r, 0, Math.PI*2);
                ctx.fillStyle = h.color;
                ctx.fill();
                // í…Œë‘ë¦¬
                ctx.lineWidth = 3;
                ctx.strokeStyle = h.rimColor;
                ctx.stroke();

                // ì´ë¦„
                ctx.fillStyle = '#333';
                ctx.font = `bold ${Math.max(12, h.r/3)}px Noto Sans KR`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(h.name, h.x, h.y);

                // ì¶©ëŒ ê²€ì‚¬ (ì‚¬ë¬¼ ë¨¹ê¸°)
                props.forEach(p => {
                    if(p.suckTarget) return; // ì´ë¯¸ ë¹¨ë ¤ê°€ëŠ” ì¤‘
                    let dist = Math.hypot(h.x - p.x, h.y - p.y);
                    // ë‚´ ë°˜ì§€ë¦„ë³´ë‹¤ ì‚¬ë¬¼ì´ ì‘ê³ , ì‚¬ë¬¼ì´ ì¤‘ì‹¬ë¶€ ê·¼ì²˜ì— ì˜¤ë©´ ë¹¨ì•„ë“¤ì„
                    // ë‹¨, ë¬¼ë¦¬ì ìœ¼ë¡œ ì‚¬ë¬¼ ì¤‘ì‹¬ì´ êµ¬ë© ì•ˆì— ë“¤ì–´ì™€ì•¼ í•¨
                    if(dist < h.r && h.r > p.r) {
                        p.suckTarget = h; // ë¹¨ë ¤ ë“¤ì–´ê° ì‹œì‘
                    }
                });

                // ì¶©ëŒ ê²€ì‚¬ (ë‹¤ë¥¸ ë¸”ë™í™€ ë¨¹ê¸°)
                holes.forEach((other, oIdx) => {
                    if(h === other || other.dead) return;
                    let dist = Math.hypot(h.x - other.x, h.y - other.y);
                    
                    // ì¤‘ì‹¬ì´ ê²¹ì¹˜ê³  í¬ê¸° ì°¨ì´ê°€ ë‚˜ë©´
                    if(dist < h.r && h.r > other.r * 1.1) {
                        // hê°€ otherë¥¼ ë¨¹ìŒ
                        h.r += other.r * 0.2;
                        h.score += 50;
                        killHole(oIdx);
                    }
                });
            });

            ctx.restore();
            
            // ì‚¬ë¬¼ ë¦¬í•„ (ë„ˆë¬´ ì¤„ì–´ë“¤ë©´)
            if(props.length < 500) addProp();

            updateLeaderboard();
            animationFrameId = requestAnimationFrame(loop);
        }

        function killHole(idx) {
            let h = holes[idx];
            h.dead = true;
            
            if(h.isHuman) gameOver(h.name); // ë‚´ê°€ ì£½ìŒ (ì´ë¦„ì€ ë²„ê·¸ ë°©ì§€ìš©)
            else {
                showKillLog(`${h.name} ì†Œë©¸!`);
                setTimeout(() => { if(gameRunning) { holes.splice(idx, 1); addHole(false); } }, 3000);
            }
        }

        function showKillLog(msg) {
            killLog.innerText = msg; killLog.style.opacity = 1;
            setTimeout(() => { killLog.style.opacity = 0; }, 2000);
        }

        function updateLeaderboard() {
            let list = [...holes].filter(h => !h.dead).sort((a,b) => b.r - a.r);
            let html = '';
            for(let i=0; i<Math.min(5, list.length); i++) {
                let h = list[i];
                let name = h.isHuman ? `<span style="color:#6c5ce7">${h.name}</span>` : h.name;
                html += `<li>${i+1}. ${name} <small>(${Math.floor(h.r)})</small></li>`;
            }
            rankList.innerHTML = html;
        }

        function gameOver(killer) {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            ingameAd.style.display = 'none';
            ui.style.display = 'block';
            
            const btn = document.getElementById('start-btn');
            btn.innerText = "ë‹¤ì‹œ ì‚¼í‚¤ê¸° â†º";
            ui.querySelector('h1').innerText = "ğŸ’€ ì†Œë©¸ë¨";
            
            // killer ì¸ìê°€ ì—†ê±°ë‚˜ ì—‰ëš±í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ í…ìŠ¤íŠ¸ ê³ ì •
            ui.querySelector('p').innerHTML = `
                ë” í° ë¸”ë™í™€ì—ê²Œ í¡ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
                ìµœì¢… í¬ê¸°: <span style="color:#6c5ce7; font-weight:bold;">${Math.floor(holes[playerIndex].r)}</span>
            `;
        }
    </script>
</body>
</html>

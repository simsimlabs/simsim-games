<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë•…ë”°ë¨¹ê¸° - ì‹¬ì‹¬í’€ì´ ê²Œì„ ì—°êµ¬ì†Œ</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2261846676525942" crossorigin="anonymous"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap');

        body { 
            margin: 0; padding: 0; overflow: hidden; background-color: #2c3e50; 
            font-family: 'Noto Sans KR', sans-serif; user-select: none; touch-action: none;
        }

        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        .game-overlay { pointer-events: none; position: fixed; z-index: 100; }

        #game-ui { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 9999; background: rgba(255, 255, 255, 0.98);
            padding: 40px; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            text-align: center; width: 90%; max-width: 420px; border: 5px solid #6c5ce7;
            pointer-events: auto;
        }

        #game-ui h1 { font-family: 'Jua', sans-serif; font-size: 3rem; color: #6c5ce7; margin: 0 0 10px 0; text-shadow: 2px 2px 0px #a29bfe; }
        #game-ui p { color: #636e72; font-size: 1.1rem; margin-bottom: 20px; }

        #start-btn {
            background: #ff7675; color: white; border: none; padding: 15px 0;
            font-size: 1.8rem; font-family: 'Jua', sans-serif; border-radius: 50px;
            cursor: pointer; box-shadow: 0 6px 0 #d63031; width: 100%; margin-bottom: 15px; transition: transform 0.1s; display: block;
        }
        #start-btn:active { transform: translateY(4px); box-shadow: none; }

        .back-link { display: inline-block; margin-top: 10px; color: #b2bec3; text-decoration: none; cursor: pointer; }
        .back-link:hover { color: #636e72; text-decoration: underline; }

        #leaderboard { top: 15px; right: 15px; background: rgba(0,0,0,0.6); color: white; padding: 15px; border-radius: 10px; font-family: 'Jua', sans-serif; min-width: 160px; }
        #rank-list { list-style: none; padding: 0; margin: 0; font-size: 0.95rem; }
        #rank-list li { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }

        #kill-log { bottom: 120px; left: 50%; transform: translateX(-50%); background: rgba(231, 76, 60, 0.9); color: white; padding: 10px 25px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s; }

        #ingame-ad { position: fixed; bottom: 10px; right: 10px; z-index: 50; background: white; padding: 5px; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.2); pointer-events: auto; display: none; }
        .ad-label { font-size: 10px; color: #ccc; text-align: right; display: block; }

        #joystick-zone { position: fixed; bottom: 30px; left: 30px; width: 120px; height: 120px; z-index: 200; display: none; pointer-events: auto; }
        #joystick-bg { width: 100%; height: 100%; background: rgba(255, 255, 255, 0.2); border-radius: 50%; position: relative; border: 2px solid rgba(255,255,255,0.5); }
        #joystick-stick { width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(0,0,0,0.2); }

        @media (max-width: 600px) {
            #game-ui { width: 85%; }
            #ingame-ad { transform: scale(0.8); transform-origin: bottom right; bottom: 5px; right: 5px; }
            #joystick-zone { display: block; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="leaderboard" class="game-overlay">
        <h3>ğŸ† ë•… ì ìœ ìœ¨</h3>
        <ul id="rank-list"><li>ë¡œë”© ì¤‘...</li></ul>
    </div>

    <div id="kill-log" class="game-overlay"></div>

    <div id="joystick-zone">
        <div id="joystick-bg"><div id="joystick-stick"></div></div>
    </div>

    <div id="ingame-ad">
        <span class="ad-label">Sponsored</span>
        <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-2261846676525942" data-ad-slot="4380369066"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <div id="game-ui">
        <h1>ğŸš© ë•…ë”°ë¨¹ê¸°</h1>
        <p>
            ì„ ì„ ê·¸ë ¤ ë‚´ ë•…ì„ ë„“íˆì„¸ìš”!<br>
            ê¼¬ë¦¬ë¥¼ ë°Ÿíˆë©´ ì£½ìŠµë‹ˆë‹¤.<br>
        </p>
        <div style="margin: 15px 0; min-height: 100px; overflow:hidden;">
             <ins class="adsbygoogle" style="display:block; height: 100px;" data-ad-client="ca-pub-2261846676525942" data-ad-slot="4380369066" data-ad-format="horizontal" data-full-width-responsive="true"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        <button id="start-btn">ê²Œì„ ì‹œì‘ â–¶</button>
        <br>
        <a href="index.html" class="back-link">ğŸ  ë©”ì¸ìœ¼ë¡œ ë‚˜ê°€ê¸°</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('game-ui');
        const rankList = document.getElementById('rank-list');
        const killLog = document.getElementById('kill-log');
        const ingameAd = document.getElementById('ingame-ad');
        const startBtn = document.getElementById('start-btn');
        const joystickZone = document.getElementById('joystick-zone');
        const joystickStick = document.getElementById('joystick-stick');

        // ê²Œì„ ì„¤ì •
        const GRID_SIZE = 25; // ê·¸ë¦¬ë“œ í¬ê¸° í‚¤ì›€ (ê°€ì‹œì„± í™•ë³´)
        const MAP_WIDTH = 100; // ë§µ ë„ˆë¹„ (ì¹¸ ìˆ˜)
        const MAP_HEIGHT = 100; // ë§µ ë†’ì´ (ì¹¸ ìˆ˜)
        
        let map = []; 
        let players = [];
        let gameRunning = false;
        let animationFrameId;
        let frameCount = 0;

        const adjectives = ["ë°°ê³ í”ˆ", "ë„¤ëª¨ë‚œ", "ë¹ ë¥¸", "ìš©ê°í•œ", "ìˆ˜ìƒí•œ", "ì²œì¬", "ë°”ë³´", "ì¦ê±°ìš´", "ê±°ëŒ€í•œ", "ì†Œì‹¬í•œ"];
        const nouns = ["ë•…ë¶€ì", "ê±´ë¬¼ì£¼", "ì§€ë ì´", "ë„¤ëª¨", "íƒ±í¬", "ê°œë¯¸", "ë…ìˆ˜ë¦¬", "í˜¸ë‘ì´", "ê°œë°œì", "ê²Œì´ë¨¸"];
        function getName() { return adjectives[Math.floor(Math.random()*adjectives.length)] + " " + nouns[Math.floor(Math.random()*nouns.length)]; }

        document.addEventListener('DOMContentLoaded', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            if(startBtn) startBtn.addEventListener('click', startGame);
            initJoystick();
            window.addEventListener('keydown', handleKey);
        });

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            // ì¢Œí‘œê³„ ì´ˆê¸°í™”
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ë§µ ìƒì„± (100x100)
            map = [];
            for(let y=0; y<MAP_HEIGHT; y++) {
                let row = [];
                for(let x=0; x<MAP_WIDTH; x++) row.push(0);
                map.push(row);
            }

            players = [];
            spawnPlayer(1, true); // ë‚˜
            for(let i=2; i<=15; i++) spawnPlayer(i, false); // ë´‡

            gameRunning = true;
            ui.style.display = 'none';
            ingameAd.style.display = 'block';
            frameCount = 0;
            loop();
        }

        function spawnPlayer(id, isHuman) {
            let x = Math.floor(Math.random() * (MAP_WIDTH - 10)) + 5;
            let y = Math.floor(Math.random() * (MAP_HEIGHT - 10)) + 5;
            
            // ì´ˆê¸° ë•… ìƒì„±
            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    map[y+dy][x+dx] = id;
                }
            }

            players.push({
                id: id, isHuman: isHuman,
                x: x, y: y, dx: 1, dy: 0, nextDx: 1, nextDy: 0,
                color: isHuman ? '#e74c3c' : `hsl(${Math.random()*360}, 70%, 50%)`,
                name: isHuman ? 'ë‚˜ (Player)' : getName(),
                trail: [], score: 9, dead: false
            });
        }

        function handleKey(e) {
            if(!gameRunning) return;
            const p = players.find(p => p.isHuman);
            if(!p || p.dead) return;

            if(e.key === 'ArrowUp' && p.dy !== 1) { p.nextDx = 0; p.nextDy = -1; }
            if(e.key === 'ArrowDown' && p.dy !== -1) { p.nextDx = 0; p.nextDy = 1; }
            if(e.key === 'ArrowLeft' && p.dx !== 1) { p.nextDx = -1; p.nextDy = 0; }
            if(e.key === 'ArrowRight' && p.dx !== -1) { p.nextDx = 1; p.nextDy = 0; }
        }

        function initJoystick() {
            let active = false; let startX, startY;
            const zone = joystickZone;
            
            zone.addEventListener('touchstart', e => {
                e.preventDefault(); active = true;
                let t = e.touches[0]; startX = t.clientX; startY = t.clientY;
                joystickStick.style.transition = 'none';
            }, {passive:false});

            zone.addEventListener('touchmove', e => {
                if(!active) return;
                e.preventDefault();
                let t = e.touches[0];
                let dx = t.clientX - startX; let dy = t.clientY - startY;
                let dist = Math.min(30, Math.sqrt(dx*dx + dy*dy));
                let angle = Math.atan2(dy, dx);
                joystickStick.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;

                if(dist > 10) {
                    const p = players.find(p => p.isHuman);
                    if(p && !p.dead) {
                        if(Math.abs(dx) > Math.abs(dy)) {
                            if(dx > 0 && p.dx !== -1) { p.nextDx = 1; p.nextDy = 0; }
                            else if(dx < 0 && p.dx !== 1) { p.nextDx = -1; p.nextDy = 0; }
                        } else {
                            if(dy > 0 && p.dy !== -1) { p.nextDx = 0; p.nextDy = 1; }
                            else if(dy < 0 && p.dy !== 1) { p.nextDx = 0; p.nextDy = -1; }
                        }
                    }
                }
            }, {passive:false});

            zone.addEventListener('touchend', e => {
                e.preventDefault(); active = false;
                joystickStick.style.transform = `translate(-50%, -50%)`;
            });
        }

        function loop() {
            if(!gameRunning) return;

            // [ì†ë„ ì¡°ì ˆ] 3 -> 6 (ìˆ«ìê°€ í´ìˆ˜ë¡ ëŠë ¤ì§)
            frameCount++;
            if(frameCount % 6 === 0) {
                update();
            }
            draw();
            animationFrameId = requestAnimationFrame(loop);
        }

        function update() {
            players.forEach(p => {
                if(p.dead) return;

                if(!p.isHuman) {
                    // AI: ëœë¤ ì´ë™ + ë²½ íšŒí”¼
                    if(Math.random() < 0.05) {
                        const dirs = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
                        const randDir = dirs[Math.floor(Math.random()*dirs.length)];
                        if(randDir.dx !== -p.dx || randDir.dy !== -p.dy) { p.nextDx = randDir.dx; p.nextDy = randDir.dy; }
                    }
                    // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë ¤ í•˜ë©´ ë°©í–¥ ì „í™˜
                    let futureX = p.x + p.nextDx;
                    let futureY = p.y + p.nextDy;
                    if(futureX < 0 || futureX >= MAP_WIDTH || futureY < 0 || futureY >= MAP_HEIGHT) {
                        if(p.dx !== 0) { p.nextDx = 0; p.nextDy = 1; }
                        else { p.nextDx = 1; p.nextDy = 0; }
                    }
                }

                p.dx = p.nextDx; p.dy = p.nextDy;
                let nx = p.x + p.dx; let ny = p.y + p.dy;

                // ì‚¬ë§ ì¡°ê±´: ë²½ ì¶©ëŒ
                if(nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) { killPlayer(p, "ë²½ ì¶©ëŒ"); return; }
                // ì‚¬ë§ ì¡°ê±´: ìê¸° ê¼¬ë¦¬ ë°ŸìŒ
                if(p.trail.some(t => t.x === nx && t.y === ny)) { killPlayer(p, "ìê¸° ê¼¬ë¦¬"); return; }

                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ì˜ ìƒí˜¸ì‘ìš©
                players.forEach(other => {
                    if(p === other || other.dead) return;
                    // ë‚¨ì˜ ê¼¬ë¦¬ ëŠê¸°
                    if(other.trail.some(t => t.x === nx && t.y === ny)) {
                        killPlayer(other, p.name);
                        if(p.isHuman) showKillLog(`${other.name}ë‹˜ì„ ëŠì—ˆìŠµë‹ˆë‹¤!`);
                    }
                    // ë¨¸ë¦¬ ì¶©ëŒ
                    if(other.x === nx && other.y === ny) { killPlayer(p, "ì¶©ëŒ"); killPlayer(other, "ì¶©ëŒ"); }
                });

                if(p.dead) return;

                p.x = nx; p.y = ny;

                // ë‚´ ë•… ë„ì°©
                if(map[ny][nx] === p.id) {
                    if(p.trail.length > 0) {
                        p.trail.forEach(t => map[t.y][t.x] = p.id);
                        
                        // ì‚¬ê°í˜• ì±„ìš°ê¸° ì•Œê³ ë¦¬ì¦˜ (ê°„ì´)
                        let minX=p.x, maxX=p.x, minY=p.y, maxY=p.y;
                        p.trail.forEach(t => {
                            minX = Math.min(minX, t.x); maxX = Math.max(maxX, t.x);
                            minY = Math.min(minY, t.y); maxY = Math.max(maxY, t.y);
                        });
                        for(let cy=minY; cy<=maxY; cy++) {
                            for(let cx=minX; cx<=maxX; cx++) {
                                // ê°„ë‹¨í•˜ê²Œ ë¹ˆë•…ì´ê±°ë‚˜ ê¼¬ë¦¬ ë‚´ë¶€ë©´ ë¨¹ìŒ
                                if(map[cy][cx] !== p.id) map[cy][cx] = p.id; 
                            }
                        }

                        p.trail = [];
                        p.score = countScore(p.id);
                    }
                } else {
                    p.trail.push({x: nx, y: ny});
                }
            });
            updateLeaderboard();
        }

        function killPlayer(p, reason) {
            p.dead = true; p.trail = [];
            // ë•…ì€ ë‚¨ê²¨ë‘  (ìœ ë ¹ ë•…ì´ ë¨)
            if(p.isHuman) gameOver(reason);
            else setTimeout(() => { if(gameRunning) spawnPlayer(p.id, false); }, 2000);
        }

        function countScore(id) {
            let s = 0;
            for(let y=0; y<MAP_HEIGHT; y++) for(let x=0; x<MAP_WIDTH; x++) if(map[y][x] === id) s++;
            return s;
        }

        function draw() {
            // [ì¤‘ìš”] ì¹´ë©”ë¼ ë¡œì§ ì ìš©
            ctx.setTransform(1, 0, 0, 1, 0, 0); // ì´ˆê¸°í™”
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const p = players.find(pl => pl.isHuman);
            if(!p) return; // ë¡œë”©ì¤‘

            let camX = p.x * GRID_SIZE - canvas.width / 2;
            let camY = p.y * GRID_SIZE - canvas.height / 2;
            
            ctx.translate(-camX, -camY);

            // ê²©ì ê·¸ë¦¬ê¸° (ë°°ê²½)
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // í™”ë©´ì— ë³´ì´ëŠ” ì˜ì—­ë§Œ ê·¸ë¦¬ê¸° ìµœì í™”
            let startCol = Math.floor(camX / GRID_SIZE);
            let endCol = startCol + (canvas.width / GRID_SIZE) + 1;
            let startRow = Math.floor(camY / GRID_SIZE);
            let endRow = startRow + (canvas.height / GRID_SIZE) + 1;

            for (let x = startCol; x <= endCol; x++) {
                ctx.moveTo(x * GRID_SIZE, camY);
                ctx.lineTo(x * GRID_SIZE, camY + canvas.height + GRID_SIZE);
            }
            for (let y = startRow; y <= endRow; y++) {
                ctx.moveTo(camX, y * GRID_SIZE);
                ctx.lineTo(camX + canvas.width + GRID_SIZE, y * GRID_SIZE);
            }
            ctx.stroke();

            // ë§µ ê²½ê³„ì„ 
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, MAP_WIDTH * GRID_SIZE, MAP_HEIGHT * GRID_SIZE);

            // ë•… ê·¸ë¦¬ê¸° (ì „ì²´ ìˆœíšŒëŠ” ë¹„íš¨ìœ¨ì ì´ì§€ë§Œ 100x100ì€ ê´œì°®ìŒ)
            for(let y=Math.max(0, startRow); y<Math.min(MAP_HEIGHT, endRow); y++) {
                for(let x=Math.max(0, startCol); x<Math.min(MAP_WIDTH, endCol); x++) {
                    let id = map[y][x];
                    if(id !== 0) {
                        let owner = players.find(pl => pl.id === id);
                        if(owner) {
                            ctx.fillStyle = owner.color;
                            ctx.globalAlpha = 0.4; // ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                            ctx.fillRect(x*GRID_SIZE, y*GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
            }

            // í”Œë ˆì´ì–´ & ê¼¬ë¦¬ ê·¸ë¦¬ê¸°
            players.forEach(pl => {
                if(pl.dead) return;

                // ê¼¬ë¦¬
                ctx.fillStyle = pl.color;
                ctx.globalAlpha = 0.6;
                pl.trail.forEach(t => ctx.fillRect(t.x*GRID_SIZE, t.y*GRID_SIZE, GRID_SIZE, GRID_SIZE));
                ctx.globalAlpha = 1.0;

                // ë¨¸ë¦¬ (ê·¸ë¦¼ì íš¨ê³¼ ì¶”ê°€)
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'black';
                ctx.fillStyle = pl.color;
                ctx.fillRect(pl.x*GRID_SIZE, pl.y*GRID_SIZE, GRID_SIZE, GRID_SIZE);
                ctx.shadowBlur = 0;

                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(pl.x*GRID_SIZE, pl.y*GRID_SIZE, GRID_SIZE, GRID_SIZE);

                // ì´ë¦„
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Noto Sans KR';
                ctx.textAlign = 'center';
                // ì´ë¦„ì´ ë§µ ë°–ìœ¼ë¡œ ì•ˆ ë‚˜ê°€ê²Œ ì‚´ì§ ì¡°ì •ì€ ìƒëµ (ì‹¬í”Œí•˜ê²Œ)
                ctx.fillText(pl.name, pl.x*GRID_SIZE + GRID_SIZE/2, pl.y*GRID_SIZE - 5);
            });
        }

        function showKillLog(msg) {
            killLog.innerText = msg; killLog.style.opacity = 1;
            setTimeout(() => { killLog.style.opacity = 0; }, 2000);
        }

        function updateLeaderboard() {
            let list = [...players].sort((a,b) => b.score - a.score);
            let html = '';
            for(let i=0; i<Math.min(5, list.length); i++) {
                let p = list[i];
                let name = p.isHuman ? `<span style="color:#fd79a8">${p.name}</span>` : p.name;
                html += `<li>${i+1}. ${name} <small>(${p.score})</small></li>`;
            }
            rankList.innerHTML = html;
        }

        function gameOver(reason) {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            ingameAd.style.display = 'none';
            ui.style.display = 'block';
            
            const btn = document.getElementById('start-btn');
            btn.innerText = "ë‹¤ì‹œ ë„ì „í•˜ê¸° â†º";
            ui.querySelector('h1').innerText = "ğŸ’€ ê²Œì„ ì˜¤ë²„";
            
            const p = players.find(p => p.isHuman);
            ui.querySelector('p').innerHTML = `
                ì‚¬ë§ ì›ì¸: <b>${reason}</b><br>
                ìµœì¢… ë•… í¬ê¸°: <span style="color:#6c5ce7; font-weight:bold;">${p ? p.score : 0}</span>ì¹¸
            `;
        }
    </script>
</body>
</html>

